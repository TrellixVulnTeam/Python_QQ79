# -*- coding: utf-8 -*-
"""ZAP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FQ4ctm30qRTOyNJPgJ6FUeP_B0SC457K

Algumas perguntas que poderão te ajudar a criar o racional:

1) Quantos anúncios ativos no site exibem endereço completo?

2) Quantos anúncios ativos no site receberam leads?

3) O desempenho é uniforme para todos os segmentos de anúncios?

4) Quais outras variáveis tem relação com a quantidade de leads?
"""

#IMPORTANDO AS BIBLIOTECAS
import pandas as pd
import io
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

from google.colab import files  # IMPORTAR O listings.csv  PARA DATA FRAME df_list
uploaded = files.upload()
df_list = pd.read_csv(io.BytesIO(uploaded['listings.csv']), sep=',', header=0)

"""Scatter Plot - Mostra a relação entre duas variaveis

Predictor/independent on X axis
Target/dependent o Y axis EX : Price (Y) / Engine Size (X)
"""

from google.colab import files  # IMPORTAR O leads.csv  PARA O DATA FRAME df_leads
uploaded = files.upload()

df_leads = pd.read_csv(io.BytesIO(uploaded['leads.csv']), sep=',', header=0)

#JUNTANDO AS DUAS BASE EM UMA SÓ (df3). UTILIZANDO listing_id como chave
df3 = pd.merge(df_leads,df_list,how='inner', on=['listing_id'],suffixes=('_le', '_li'))
df3.head(30)

#TRANSFORMANDO AS COLUNAS 
# Coluna leads e price EM VARIAVEIS DO TIPO int. E substituindo NaN por null.
df3['leads'] = df3['leads'].astype(int)
df3['price'] = df3['price'].astype(int)
df3.fillna("",inplace= True)              #Trocando valores NaN por ""

#adicionar uma colunar para verificar se o endereço é completo ou incompleto;
df3['status_end'] = np.where((df3['street']== "") | (df3['CEP']== "") | (df3['street_number']== ""), "INCOMPLETO", "COMPLETO")

df3.head(30)

# 1) Quantos anúncios ativos no site exibem endereço completo?
status_end_count = df3["status_end"].value_counts(normalize=True) # criar o objeto status_end_count para atribuir a contagem de status do endereço
status_end_count.index.name = "status_end"          
status_end_count                                                  # 75% dos anuncios possuem o endereço completo

# 1.1) Agrupando por tipo de endereço e seu status, e verificando a % distribuida.
status_end_count2 = df3.groupby("display_address_type")["status_end"].value_counts(normalize = True) # criar o objeto status_end_count para atribuir a contagem de status do endereço
status_end_count2.index.name = "status_end"   
plt.title('% Total de Status_end')       
status_end_count2.plot(kind='barh', stacked=True,color=['green', 'green', 'black', 'black', 'blue','blue'])
status_end_count2
#for index, value in enumerate(status_end_count2):
#   plt.text(value, index, str(value))

# 1.2) Utilizando o agrupamento acima para verificar a % de leads
status_end_count3 = df3.groupby(["display_address_type","status_end"])['leads'].sum() # criar o objeto status_end_count para atribuir a contagem de status do endereço
status_end_count3.index.name = "status_end"
plt.title('%Total de leads por Status_end')
c= status_end_count3 / status_end_count3.groupby(level=0).sum()
c.plot(kind='barh', stacked=True,color=['green', 'green', 'black', 'black', 'blue','blue'])
c

# ANALISE EXPLORATORIA - 
#Verificando a distribuição de leads, vemos a média em 2,6 leads, portanto temos um outlier com 152 leads. 
df3['leads'].describe()

#PLOTANDO UM HISTOGRAMA PARA VERIFICAR A DISTRIBUIÇÃO DE LEADS
#verificamos uma grande concentração de quantidade de leads entre 1 e 5
df3.hist(column='leads', bins = 40)
plt.show()

group = df3[['leads']].groupby(df3[['unit_type']])
group.mean()
#group['leads'].plot(kind='hist')

# GRAFICO BEDROOM X LEADS - Scatter Plot - Mostra a relação entre duas variaveis

x = (df3['bedrooms'])
y = df3['leads']
plt.scatter(x,y)     # o terceiro argumento é o simbolo, o quarto é a cor
plt.title('bedrooms x Leads')
plt.xlabel('bedrooms')
plt.ylabel('leads')

# GRAFICO SUITES X LEADS - Scatter Plot - Mostra a relação entre duas variaveis

x = (df3['suites'])
y = df3['leads']
plt.scatter(x,y,)     
plt.title('suites x Leads')
plt.xlabel('suites')
plt.ylabel('leads')

# GRAFICO USABLE_AREAS X LEADS - Scatter Plot - Mostra a relação entre duas variaveis
x = df3['usable_areas']
y = df3['leads']
plt.scatter(x,y)     
plt.title('usable_areas x Leads')
plt.xlabel('usable_areas')
plt.ylabel('leads')
# verificamos uma grande concentração de leads com áreas até 250 m2

#3) UNIT_TYPE X STATUS X LEADS - verificar dentro dos tipos de residencia, em qual temos a maior influencia de endereço completo ou incompleto
df_teste = df3[['unit_type','display_address_type','status_end','leads']]
df_gr = df_teste.groupby(['unit_type','display_address_type','status_end']).mean()
df_gr.plot(kind='barh', stacked=True,color=['green', 'green', 'black', 'black', 'blue','blue'])
plt.title('% Total de Status_end')   # o grafico plotado fica com muita informação, portanto irei plotar em um mapa de calor

df_gr = df_gr.unstack(level=0) # primeiro é necessario pivotar os dados, assim temos a tabela mais organizada.
df_gr

#plotando o mapa de calor com a relação unit_type x display_address_type x status_end x leads.
fig, ax = plt.subplots(figsize=(11, 9)) 
sns.heatmap(df_gr, cmap="summer",linewidth=0.3, cbar_kws={"shrink": 1})
plt.show()